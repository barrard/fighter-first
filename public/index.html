<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Multiplayer Platform Game</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #f0f0f0;
                font-family: Arial, sans-serif;
            }

            #gameContainer {
                position: relative;
                width: 100vw;
                height: 100vh;
            }

            #gameCanvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #87ceeb; /* Sky blue background */
            }

            #status {
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                padding: 5px 15px;
                border-radius: 5px;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                z-index: 10;
            }

            #controls {
                position: absolute;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                padding: 5px 15px;
                border-radius: 5px;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                z-index: 10;
            }
        </style>
    </head>
    <body>
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="status">Connecting to server...</div>
            <div id="controls">Controls: Use ← and → arrow keys to move, ↑ to jump</div>
        </div>

        <script src="/socket.io/socket.io.js"></script>
        <!-- Main script using ES modules -->

        <script type="module">
            import LatencyMonitor from "./js/LatencyMonitor.js";
            import InputBatchHandler from "./js/InputBatchHandler.js";

            // Debug connection
            console.log("Script started, attempting to connect to Socket.IO");

            // Connect to the server using Socket.io
            const socket = io();
            // Make it available globally if needed
            const latencyMonitor = new LatencyMonitor(socket, updateTimeOffset);
            const inputBatcher = new InputBatchHandler(socket, 50); // 50ms batching interval

            latencyMonitor.getLatency();

            // Game elements
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            const status = document.getElementById("status");

            // Add these variables at the top level of your code
            let lastInputSequenceNumber = 0;
            let pendingInputs = [];
            let serverPosition = { x: 0, y: 0, height: 0 }; // Last known authoritative position
            let stateBuffer = new Map(); // Will store timestamped state updates for each player
            // Add these variables at the top of your script
            let serverTimeOffset = 0; // Difference between client and server time
            let lastUpdateTime = 0; // Time of last server update
            let predictedStates = []; // Array to store predicted states with timestamps
            const inputCooldown = 100; // ms
            let lastInputTime = 0;
            let lastServerX = 0;
            const PREDICTION_BUFFER_MS = 100; // Allow client to be 100ms ahead

            // Game constants
            const INTERPOLATION_AMOUNT = 0.2; // Lower = smoother but less responsive
            const INTERPOLATION_DELAY = 100; // ms - buffer for smoother interpolation
            const PLAYER_WIDTH = 50;
            const PLAYER_HEIGHT = 100;
            const MOVEMENT_SPEED = 5; // Pixels per frame
            const FLOOR_HEIGHT = 40;
            let FLOOR_Y = canvas.height - FLOOR_HEIGHT;
            const JUMP_VELOCITY = -15; // Negative because y-axis increases downward
            const GRAVITY = 0.8;
            let horizontalVelocity = 0;
            const MAX_HORIZONTAL_VELOCITY = 8; // Maximum horizontal speed
            const AIR_RESISTANCE = 0; // How quickly velocity decreases in air
            const GROUND_FRICTION = 0; // How quickly velocity decreases on ground

            // Add these new constants for fighting mechanics
            const PUNCH_DURATION = 300; // milliseconds
            const KICK_DURATION = 400; // milliseconds
            const ARM_WIDTH = 30; // pixels
            const ARM_HEIGHT = 10; // pixels
            const ARM_Y_OFFSET = 30; // 70px from top of 100px character
            const LEG_WIDTH = 35; // pixels
            const LEG_HEIGHT = 8; // pixels
            const LEG_Y_OFFSET = 70; // Position from top of character

            // Add this function to interpolate between positions
            function lerp(start, end, t) {
                return start * (1 - t) + end * t;
            }

            // Add this function to sync client and server time
            function updateTimeOffset(serverTime) {
                // Simple averaging to smooth out network jitter
                const newOffset = Date.now() - serverTime;
                serverTimeOffset = serverTimeOffset * 0.8 + newOffset * 0.2;
            }

            // Set canvas to full screen
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Update floor position after resize
                FLOOR_Y = canvas.height - FLOOR_HEIGHT;

                // Debug
                console.log(`Canvas resized: ${canvas.width}x${canvas.height}, Floor Y: ${FLOOR_Y}`);
            }

            // Initial resize and event listener
            resizeCanvas();
            window.addEventListener("resize", resizeCanvas);

            // Game state
            let playerId = null;
            let players = new Map();
            let keysPressed = {
                ArrowLeft: false,
                ArrowRight: false,
                ArrowUp: false,
                p: false, // P for punch
                k: false, // K for kick
            };

            let verticalVelocity = 0;
            let isJumping = false;

            // Track movement input to send to server
            let currentMovementInput = null;
            let movementStartTime = null;

            // Add these fighting state variables
            let isPunching = false;
            let isKicking = false;
            let punchStartTime = 0;
            let kickStartTime = 0;

            // Handle connection to the server
            socket.on("connect", () => {
                console.log("Connected to server with ID:", socket.id);
                status.textContent = "Connected! Use arrow keys to move.";
            });

            // Handle disconnection
            socket.on("disconnect", () => {
                console.log("Disconnected from server");
                status.textContent = "Disconnected from server. Trying to reconnect...";
            });

            // Initialize game state
            socket.on("init", (data) => {
                console.log("Received init data:", data);
                playerId = data.playerId;

                // Add all existing players
                data.gameState.forEach((player) => {
                    // Set initial y position on the floor
                    player.y = FLOOR_Y - PLAYER_HEIGHT;
                    // Set default facing direction if not provided
                    player.facing = player.facing || "right";
                    // Initialize interpolation targets
                    player.targetX = player.x;
                    player.targetHeight = player.height || 0;
                    players.set(player.id, player);
                });

                console.log("Players initialized:", players.size);

                // Start game loop
                requestAnimationFrame(gameLoop);
            });

            // Handle new player joining
            socket.on("playerJoined", (player) => {
                console.log("New player joined:", player.id);
                // Set initial y position on the floor
                player.y = FLOOR_Y - PLAYER_HEIGHT;
                // Set default facing direction if not provided
                player.facing = player.facing || "right";
                // Initialize interpolation targets
                player.targetX = player.x;
                player.targetHeight = player.height || 0;
                players.set(player.id, player);
            });

            // Handle player movement
            // socket.on("playerMoved", (data) => {
            //     const player = players.get(data.id);
            //     if (player) {
            //         player.x = data.x;
            //         player.height = data.height || 0;
            //         player.y = FLOOR_Y - PLAYER_HEIGHT - player.height;

            //         // Update facing direction if provided
            //         if (data.facing) {
            //             player.facing = data.facing;
            //         }
            //     }
            // });

            socket.on("playerKicked", (id) => {
                const player = players.get(id);
                if (player) {
                    player.isKicking = true;
                    player.kickStartTime = Date.now();

                    // Reset kick after animation duration
                    setTimeout(() => {
                        player.isKicking = false;
                    }, KICK_DURATION);
                }
            });

            // Handle player leaving
            socket.on("playerLeft", (id) => {
                console.log("Player left:", id);
                players.delete(id);
            });

            // Modify the gameState handler for other players
            socket.on("gameState", (data) => {
                const serverTime = Date.now();

                data.players.forEach((serverPlayer) => {
                    if (serverPlayer.id === playerId) {
                        // Local player - handle with prediction/reconciliation
                        handleServerUpdate(serverPlayer);
                    } else {
                        // Other players - interpolate movement
                        let otherPlayer = players.get(serverPlayer.id);
                        if (!otherPlayer) {
                            console.log("Creating new remote player:", serverPlayer.id);
                            otherPlayer = {
                                id: serverPlayer.id,
                                x: serverPlayer.x,
                                y: FLOOR_Y - PLAYER_HEIGHT - (serverPlayer.height || 0),
                                height: serverPlayer.height || 0,
                                color: "#" + Math.floor(Math.random() * 16777215).toString(16),
                                facing: serverPlayer.facing || "right",
                                targetX: serverPlayer.x,
                                targetHeight: serverPlayer.height || 0,
                                isPunching: false,
                                isKicking: false,
                            };
                            players.set(serverPlayer.id, otherPlayer);
                        } else {
                            // Existing player - update targets for interpolation
                            otherPlayer.targetX = serverPlayer.x;
                            otherPlayer.targetHeight = serverPlayer.height || 0;

                            // Preserve visual state
                            const visualState = {
                                color: otherPlayer.color,
                                isPunching: otherPlayer.isPunching,
                                isKicking: otherPlayer.isKicking,
                            };

                            // Update other properties that don't need interpolation
                            otherPlayer.facing = serverPlayer.facing;

                            // Restore visual state
                            Object.assign(otherPlayer, visualState);
                        }
                    }
                });
            });

            // Update your sendInputState function to include timestamp
            function sendInputState() {
                if (!playerId) return;
                const player = players.get(playerId);
                if (!player) return;

                const currentTime = Date.now();

                // Create input state with client-side timestamp
                const inputState = {
                    keysPressed: { ...keysPressed },
                    isPunching: isPunching,
                    isKicking: isKicking,
                    isJumping: isJumping,
                    horizontalVelocity: horizontalVelocity,
                    verticalVelocity: verticalVelocity,
                    x: player.x,
                    y: player.y,
                    height: player.height || 0,
                    timestamp: currentTime - serverTimeOffset, // Convert to server time
                };

                // Add to batch handler and get sequence number
                const sequenceNumber = inputBatcher.addInput(inputState);

                // Store for reconciliation
                const fullInputState = {
                    ...inputState,
                    sequenceNumber: sequenceNumber,
                    clientTime: currentTime, // Keep track of client time too
                };

                pendingInputs.push(fullInputState);

                // Limit stored inputs
                if (pendingInputs.length > 30) {
                    pendingInputs.shift();
                }
            }

            // Handle keydown for movement
            window.addEventListener("keydown", (e) => {
                if (e.key in keysPressed) {
                    keysPressed[e.key] = true;

                    // Handle jump (keep local state updates)
                    if (e.key === "ArrowUp" && !isJumping) {
                        console.log("Jump key pressed");
                        verticalVelocity = JUMP_VELOCITY;
                        isJumping = true;
                        const player = players.get(playerId);
                        if (player) {
                            player.height = 0;
                        }

                        // Send input state for jumping immediately
                        sendInputState();
                        inputBatcher.flushInputs(); // Ensure jump input is sent immediately
                    }

                    // Handle punch (keep local state updates)
                    if (e.code === "KeyP" && !isPunching && !isKicking) {
                        console.log("Punch key pressed");
                        isPunching = true;
                        punchStartTime = Date.now();

                        // Send punch input immediately
                        sendInputState();
                        inputBatcher.flushInputs(); // Ensure punch input is sent immediately

                        // Keep timeout to reset animation
                        setTimeout(() => {
                            isPunching = false;
                            sendInputState(); // Send input state when punch ends
                        }, PUNCH_DURATION);
                    }

                    // Handle kick (keep local state updates)
                    if (e.code === "KeyK" && !isKicking && !isPunching) {
                        console.log("Kick key pressed");
                        isKicking = true;
                        kickStartTime = Date.now();

                        // Send kick input immediately
                        sendInputState();
                        inputBatcher.flushInputs(); // Ensure kick input is sent immediately

                        // Keep timeout to reset animation
                        setTimeout(() => {
                            isKicking = false;
                            sendInputState(); // Send input state when kick ends
                        }, KICK_DURATION);
                    }

                    // For movement, keep tracking the current movement but don't emit immediately
                    if (
                        (e.key === "ArrowLeft" || e.key === "ArrowRight") &&
                        (!currentMovementInput || currentMovementInput !== e.key)
                    ) {
                        console.log("Movement key pressed:", e.key);
                        currentMovementInput = e.key;
                        movementStartTime = Date.now();
                    }

                    // Only send input state for movement keys, not action keys which are handled above
                    if (e.key !== "ArrowUp" && e.code !== "KeyP" && e.code !== "KeyK") {
                        sendInputState();
                    }
                }
            });

            // Before unloading the page, flush any remaining inputs
            window.addEventListener("beforeunload", () => {
                inputBatcher.flushInputs();
            });

            // Update keyup event listener to be more aggressive about stopping
            window.addEventListener("keyup", (e) => {
                if (e.key in keysPressed) {
                    keysPressed[e.key] = false;

                    // For movement keys, force stop immediately
                    if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
                        // Force stop movement if we released a movement key
                        // and the other movement key isn't pressed
                        if (!(keysPressed.ArrowLeft || keysPressed.ArrowRight)) {
                            horizontalVelocity = 0;

                            // Force send the stop state
                            sendInputState();
                            inputBatcher.flushInputs();
                        }

                        // Update movement tracking
                        if (currentMovementInput === e.key) {
                            currentMovementInput = null;

                            // Check if another movement key is pressed
                            if (keysPressed.ArrowLeft) currentMovementInput = "ArrowLeft";
                            if (keysPressed.ArrowRight) currentMovementInput = "ArrowRight";
                        }
                    }

                    // Send updated input state for all keys
                    sendInputState();
                }
            });

            // Updated updateLocalPlayerPosition with smoother local prediction
            function updateLocalPlayerPosition() {
                if (!playerId) return;
                const player = players.get(playerId);
                if (!player) return;
                const currentTime = Date.now();

                // Store the pre-update position (for reconciliation)
                const previousX = player.x;
                const previousHeight = player.height || 0;

                // Check if player is on the ground or in the air
                const onGround = !isJumping;

                // Apply horizontal movement with time scaling
                if (onGround) {
                    // Direct ground control
                    if (keysPressed.ArrowLeft) {
                        horizontalVelocity = -MOVEMENT_SPEED;
                        lastInputTime = currentTime;
                    } else if (keysPressed.ArrowRight) {
                        horizontalVelocity = MOVEMENT_SPEED;
                        lastInputTime = currentTime;
                    } else {
                        // Force stop if no keys are pressed or if it's been too long since input
                        if (currentTime - lastInputTime > inputCooldown) {
                            horizontalVelocity = 0;
                        }
                    }
                } else {
                    // Air movement - just air resistance
                }

                // Apply horizontal velocity with smoothing
                player.x += horizontalVelocity;
                // Constrain player within boundaries
                player.x = Math.max(0, Math.min(canvas.width - PLAYER_WIDTH, player.x));

                // Apply gravity and jumping physics with time scaling
                if (isJumping) {
                    player.height -= verticalVelocity;
                    verticalVelocity += GRAVITY;

                    // Check if player has landed on the floor
                    if (player.height <= 0) {
                        player.height = 0;
                        verticalVelocity = 0;
                        isJumping = false;
                    }
                    player.y = FLOOR_Y - PLAYER_HEIGHT - player.height;
                }

                // Only send input state if position changed significantly
                if (Math.abs(previousX - player.x) > 0.5 || Math.abs(previousHeight - player.height) > 0.5) {
                    sendInputState();
                }
            }

            // New function to apply a single input and update physics
            function applyInput(player, input) {
                // Check if player is on ground or in air
                const onGround = !isJumping;

                // Apply horizontal movement
                if (onGround) {
                    // Ground movement
                    if (input.keysPressed.ArrowLeft) {
                        horizontalVelocity = -MOVEMENT_SPEED;
                    } else if (input.keysPressed.ArrowRight) {
                        horizontalVelocity = MOVEMENT_SPEED;
                    } else {
                        horizontalVelocity = 0;
                    }
                } else {
                    // In air - maintain momentum, no changes
                }

                // Apply position change
                player.x += horizontalVelocity;

                // Handle jump initiation
                if (input.keysPressed.ArrowUp && !isJumping && onGround) {
                    isJumping = true;
                    verticalVelocity = JUMP_VELOCITY;
                }

                // Apply jumping physics
                if (isJumping) {
                    player.height -= verticalVelocity;
                    verticalVelocity += GRAVITY;

                    // Check landing
                    if (player.height <= 0) {
                        player.height = 0;
                        verticalVelocity = 0;
                        isJumping = false;
                    }

                    player.y = FLOOR_Y - PLAYER_HEIGHT - player.height;
                }

                // Keep player in bounds
                player.x = Math.max(0, Math.min(canvas.width - PLAYER_WIDTH, player.x));
            }

            // Modify handleServerUpdate to better handle time differences
            function handleServerUpdate(serverPlayer) {
                if (!playerId) return;
                const player = players.get(playerId);
                if (!player) return;

                // Record time of this update
                const currentTime = Date.now();

                // This is the server state time in client clock
                const serverStateClientTime = currentTime - latencyMonitor.getLatency();

                // Allow some prediction buffer - don't correct if we're just slightly ahead
                const effectiveServerTime = serverStateClientTime + PREDICTION_BUFFER_MS;

                // Skip too old updates (network hiccup)
                if (lastUpdateTime > serverStateClientTime + 100) {
                    console.log("Skipping outdated server update");
                    return;
                }

                lastUpdateTime = currentTime;

                // Remove acknowledged inputs
                if (serverPlayer.lastProcessedInput) {
                    pendingInputs = pendingInputs.filter(
                        (input) => input.sequenceNumber > serverPlayer.lastProcessedInput
                    );
                }

                // Preserve visual state
                const visualState = {
                    color: player.color,
                    id: player.id,
                    isPunching: player.isPunching,
                    isKicking: player.isKicking,
                };

                // Calculate how much we've moved since server state
                // Only apply server correction if really needed
                const positionDiff = Math.abs(serverPlayer.x - player.x);
                const jumpStateChanged =
                    (serverPlayer.isJumping !== undefined ? serverPlayer.isJumping : serverPlayer.height > 0) !==
                    isJumping;

                // If major differences, accept server state
                if (positionDiff > 20 || jumpStateChanged) {
                    // Apply server state
                    player.x = serverPlayer.x;
                    player.height = serverPlayer.height || 0;
                    player.y = FLOOR_Y - PLAYER_HEIGHT - player.height;
                    isJumping = serverPlayer.isJumping !== undefined ? serverPlayer.isJumping : serverPlayer.height > 0;
                    horizontalVelocity = serverPlayer.horizontalVelocity || 0;
                    verticalVelocity = serverPlayer.verticalVelocity || 0;

                    // Replay inputs that happened after server state
                    pendingInputs.forEach((input) => {
                        if (input.clientTime >= effectiveServerTime) {
                            applyInput(player, input);
                        }
                    });
                }

                // Always update facing direction
                if (serverPlayer.facing) {
                    player.facing = serverPlayer.facing;
                }

                // Restore visual state
                Object.assign(player, visualState);
            }
            function gameLoop() {
                // Debug current players
                const localPlayer = players.get(playerId);
                const remotePlayers = Array.from(players.values()).filter((p) => p.id !== playerId);
                console.log(`Players in map - Local: ${localPlayer ? "yes" : "no"}, Remote: ${remotePlayers.length}`);
                console.log("Remote player IDs:", remotePlayers.map((p) => p.id).join(", "));

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Update local player position for responsive feel
                updateLocalPlayerPosition();

                // Apply interpolation to other players ONLY ONCE
                players.forEach((player) => {
                    if (player.id !== playerId) {
                        // Only interpolate remote players
                        if (player.targetX !== undefined) {
                            player.x = lerp(player.x, player.targetX, INTERPOLATION_AMOUNT);
                        }
                        if (player.targetHeight !== undefined) {
                            player.height = lerp(player.height, player.targetHeight, INTERPOLATION_AMOUNT);
                            player.y = FLOOR_Y - PLAYER_HEIGHT - player.height;
                        }
                    }
                });
                // Draw floor
                ctx.fillStyle = "#8B4513"; // Brown floor
                ctx.fillRect(0, FLOOR_Y, canvas.width, FLOOR_HEIGHT);

                // Draw grass on top of floor
                ctx.fillStyle = "#228B22"; // Forest green
                ctx.fillRect(0, FLOOR_Y, canvas.width, 5);

                // Draw all players
                players.forEach((player) => {
                    // Skip local player
                    // if (player.id === playerId) return;
                    // Interpolate x position

                    // Draw player rectangle
                    ctx.fillStyle = player.color || "#FF0000"; // Default to red if no color
                    ctx.fillRect(player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT);

                    // Draw punching animation (arm extension)
                    if (player.isPunching || (player.id === playerId && isPunching)) {
                        ctx.fillStyle = "#FF9999"; // Lighter color for the arm

                        // Position arm based on facing direction
                        if (player.facing === "right") {
                            ctx.fillRect(
                                player.x + PLAYER_WIDTH, // Start at right edge of player
                                player.y + ARM_Y_OFFSET, // Position at 70px from top (30px from top of 100px character)
                                ARM_WIDTH,
                                ARM_HEIGHT
                            );
                        } else {
                            ctx.fillRect(
                                player.x - ARM_WIDTH, // Start at left edge and extend left
                                player.y + ARM_Y_OFFSET,
                                ARM_WIDTH,
                                ARM_HEIGHT
                            );
                        }
                    }

                    // Draw kicking animation (leg extension)
                    if (player.isKicking || (player.id === playerId && isKicking)) {
                        ctx.fillStyle = "#FF9999"; // Lighter color for the leg

                        // Position leg based on facing direction
                        if (player.facing === "right") {
                            ctx.fillRect(
                                player.x + PLAYER_WIDTH, // Start at right edge of player
                                player.y + LEG_Y_OFFSET, // Position at lower part of character
                                LEG_WIDTH,
                                LEG_HEIGHT
                            );
                        } else {
                            ctx.fillRect(
                                player.x - LEG_WIDTH, // Start at left edge and extend left
                                player.y + LEG_Y_OFFSET,
                                LEG_WIDTH,
                                LEG_HEIGHT
                            );
                        }
                    }

                    // Draw direction indicator (triangle pointing in the facing direction)
                    ctx.fillStyle = "black";
                    const midY = player.y + PLAYER_HEIGHT / 2;

                    if (player.facing === "right") {
                        // Draw triangle pointing right
                        ctx.beginPath();
                        ctx.moveTo(player.x + PLAYER_WIDTH, midY);
                        ctx.lineTo(player.x + PLAYER_WIDTH - 15, midY - 10);
                        ctx.lineTo(player.x + PLAYER_WIDTH - 15, midY + 10);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // facing left
                        // Draw triangle pointing left
                        ctx.beginPath();
                        ctx.moveTo(player.x, midY);
                        ctx.lineTo(player.x + 15, midY - 10);
                        ctx.lineTo(player.x + 15, midY + 10);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Draw eyes to indicate facing direction
                    ctx.fillStyle = "white";
                    if (player.facing === "right") {
                        // Right-facing eyes
                        ctx.beginPath();
                        ctx.arc(player.x + PLAYER_WIDTH - 15, player.y + 30, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(player.x + PLAYER_WIDTH - 30, player.y + 30, 5, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupils
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(player.x + PLAYER_WIDTH - 13, player.y + 30, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(player.x + PLAYER_WIDTH - 28, player.y + 30, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Left-facing eyes
                        ctx.beginPath();
                        ctx.arc(player.x + 15, player.y + 30, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(player.x + 30, player.y + 30, 5, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupils
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(player.x + 13, player.y + 30, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(player.x + 28, player.y + 30, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Highlight current player
                    if (player.id === playerId) {
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT);

                        // Add "YOU" label
                        ctx.fillStyle = "black";
                        ctx.font = "12px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText("YOU", player.x + PLAYER_WIDTH / 2, player.y - 10);
                    }
                });

                // Update player count
                status.textContent = `Connected Players: ${players.size}`;

                // Continue game loop
                requestAnimationFrame(gameLoop);
            }

            // Draw initial floor even before connection
            function drawInitialScene() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw floor
                ctx.fillStyle = "#8B4513"; // Brown floor
                ctx.fillRect(0, FLOOR_Y, canvas.width, FLOOR_HEIGHT);

                // Draw grass on top of floor
                ctx.fillStyle = "#228B22"; // Forest green
                ctx.fillRect(0, FLOOR_Y, canvas.width, 5);

                // Draw loading text
                ctx.fillStyle = "black";
                ctx.font = "20px Arial";
                ctx.textAlign = "center";
                ctx.fillText("Connecting to server...", canvas.width / 2, canvas.height / 2);
            }

            // Draw initial scene
            drawInitialScene();
        </script>
    </body>
</html>
